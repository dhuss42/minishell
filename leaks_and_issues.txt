
<------------------------------------------------------------------->
[1.]

Input
			minishell: ls non_existent_file 2> error.log | cat nonexistent_file | tr '[:lower:]' '[:upper:]' > output.log

minishell output:
			cat: nonexistent_file: No such file or directory
			ls: 2: No such file or directory
			ls: non_existent_file: No such file or directory

bash output:
			bash: cat: nonexistent_file: No such file or directory

 				[----- solution idea -----]
-> returning all errors but bash returns only the first (I think)

<------------------------------------------------------------------->

minishell: $EMPTY

output with debugging

exit_code is: 0
error here in executor
exit_code is: 13
error wrapped here

				[----- solution idea -----]
-> should be 0 but is set to 13 in executor

<------------------------------------------------------------------->
[3.]
	Minishell tester passes fewer tests with init terminal

<------------------------------------------------------------------->
[4.]

minishell: cd lsd


minishell: lsd: No such file or directory
/usr/bin/cd: line 4: cd: lsd: No such file or directory

 				[----- solution idea -----]
seems like cd is called multiple times here

<------------------------------------------------------------------->

<------------------------------------------------------------------->
issues with syntax errors, segfault for some reason randomly


<------------------------------------------------------------------->

minishell: a<


minishell: syntax error near unexpected token `newline'
minishell(52160,0x113749dc0) malloc: *** error for object 0x7f98af704180: pointer being freed was not allocated
minishell(52160,0x113749dc0) malloc: *** set a breakpoint in malloc_error_break to debug
Abort trap: 6

<------------------------------------------------------------------->
echo hi > outfile not working

<------------------------------------------------------------------->
env -i ./minishell (means run minishell without environment variables) - segmentation fault
POssible: check if env[0] exists (because env for sure exists).
Expected: probably some variables are still created; check the real bash by doing "env -i bash"

<------------------------------------------------------------------->
LS, ECHO, Ls, eCHo, etc etc (and in general commands are case insensitive)
should work. Check it before!
Solution: executor_utils.c @ line 46: when check access of F_OK, before that
just transform the command to lowercase.

<------------------------------------------------------------------->
##here doc in general makes segmentations
<<eof and while waiting for input do ctrl-C (makes segmentation fault)
<<eof and while waiting for input do ctrl-D (makes segmentation fault)

<------------------------------------------------------------------->
##./lexer/ (or other directories) should give exit code == 126 (?)

<------------------------------------------------------------------->
##ctrl+D is correct: technically prints out "exit" - not really important

<------------------------------------------------------------------->
Just check: what if every variable is unset?

<------------------------------------------------------------------->
unset PATH should unset it, and after it, in case of trying a command like
ls, it should not be found; in that case only /bin/ls would work, because
an absolute path is given.
Solution: the problem is line 107 @ find_path.c, where getenv() is used.
getenv() check in the outside environment, while you should check in YOURS.
Therefor you need to re-create a custom getenv() which checks your actual
environment.

<------------------------------------------------------------------->
export | grep USER or export | grep SHLVL or something else doesnt work
Really strange error: I thought it was related to stdin and stdout with builtins,
but with echo, pwd or others, it works correctly.

<------------------------------------------------------------------->
##>helloworld should create a file: well, it is created but makes segmentation fault

<------------------------------------------------------------------->
##I create a file named like a bash command "ls" (which internally does something
random, like echo "This is my script!"). If i then type "ls" should execute /bin/bash/ls,
but if I type "./ls" should execute the file I created.
Solution: before checking the $PATH, check if before the command there are "." or "/":
in those cases DONÂ´T LOOK for the PATH variable and build the absolute path, but instead
execute is as it is.

<------------------------------------------------------------------->
When I start minishell from the directory before minishell and start
minishell again from there, then exit gives double-free-error

:/mnt/c/Users/milen/Desktop/42$ ./minishell/minishell
minishell: ./minishell/minishell
minishell:
exit
free(): double free detected in tcache 2
Aborted (core dumped)

as well with
minishell: ./minishell/ls
This is my Script!
free(): double free detected in tcache 2
Aborted (core dumped)
<------------------------------------------------------------------->

<------------------------------------------------------------------->
