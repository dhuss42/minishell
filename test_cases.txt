//--- Test for buildins ----//

echo Hello, World!
echo -n "Hello, World!"
echo "This is a test $USER"

export TESTVAR
export TESTVAR=42
export

unset TESTVAR
unset NONEXISTENT

cd/tmp
cd
cd/nonexistent

pwd
cd/tmp
pwd

exit
exit 42

echo "Hello" | grep "H"
echo "Hello World" | tr ' ' '\n' | grep "World"

echo "Hello, World!" > output.txt
Create a file input.txt containing Hello, Shell!
cat < input.txt
Create a file append.txt containing First line
echo "Second line" >> append.txt

echo "Hello World" | grep "World" > output.txt
cat input.txt | tr 'a-z' 'A-Z' | grep "HELLO" > output.txt

Jeus Christ|echo this>but her "  $HOME "'$SHLVL'|cat -e >>outfile

export a b=hi $=not_this_one c=but_this_one

//------ More complex Testcases --------//

# Complex Test Case 1: Combined echo, export, and environment variable usage
export GREETING="Hello"
echo "$GREETING, World!"
# Expected Output: Hello, World!
--> issue because of comma

# Complex Test Case 2: Multiple export commands and usage in echo
export NAME="MiniShell"
export VERSION="1.0"
echo "$NAME version $VERSION"
# Expected Output: MiniShell version 1.0

# Complex Test Case 3: Pipe and grep with environment variable
export SEARCH="Shell"
echo "Welcome to MiniShell" | grep "$SEARCH"
# Expected Output: Welcome to MiniShell

# Complex Test Case 4: Chaining cd, pwd, and echo with pipes
cd /tmp && pwd | echo "Current directory is: $(cat -)"
# Expected Output: Current directory is: /tmp

# Complex Test Case 5: Unset environment variable and verify with echo
export MYVAR="Test"
unset MYVAR
echo "$MYVAR"
# Expected Output: (empty line, variable unset)

# Complex Test Case 6: Chained cd and pwd with error handling
cd /nonexistent && echo "Changed to nonexistent" || echo "Directory not found"
# Expected Output: Directory not found

# Complex Test Case 7: Pipe, environment variable, and redirection
export PHRASE="Hello, MiniShell!"
echo "$PHRASE" | tr '[:lower:]' '[:upper:]' > output.txt
cat output.txt
# Expected Output (in output.txt): HELLO, MINISHELL!

# Complex Test Case 8: Using export, echo, and redirecting output with append
export APPEND_TEST="This is appended text."
echo "$APPEND_TEST" >> append_test.txt
cat append_test.txt
# Expected Output (in append_test.txt): (contents of previous lines, then "This is appended text.")

# Complex Test Case 9: Pipe, multiple commands, and output redirection
echo "One Two Three" | tr ' ' '\n' | grep "Two" > result.txt
cat result.txt
# Expected Output (in result.txt): Two

# Complex Test Case 10: Pipe with redirection and append in sequence
echo "First line" > chain_output.txt
echo "Second line" | tee -a chain_output.txt | grep "Second" >> chain_output.txt
cat chain_output.txt
# Expected Output (in chain_output.txt):
# First line
# Second line
# Second line

# Complex Test Case 11: Export with a multi-pipe and environment variable chaining
export GREETING="Hello"
export TARGET="Shell"
echo "$GREETING $TARGET" | tr '[:lower:]' '[:upper:]' | grep "HELLO"
# Expected Output: HELLO SHELL

# Complex Test Case 12: Redirected output from a pipe with unset verification
export REMOVE_ME="Goodbye"
echo "Removing variable" && unset REMOVE_ME && echo "$REMOVE_ME" > remove_test.txt
cat remove_test.txt
# Expected Output (in remove_test.txt): (empty, as REMOVE_ME is unset)

# Complex Test Case 13: Using cd, pwd, echo with error handling and piping
cd /tmp && pwd || echo "Could not navigate" | echo "Final directory: $(pwd)"
# Expected Output: /tmp

# Complex Test Case 14: Multi-pipe with uppercase transformation and pattern matching
echo "hello minishell" | tr '[:lower:]' '[:upper:]' | grep "MINISHELL"
# Expected Output: HELLO MINISHELL

# Complex Test Case 15: Nested pipes with redirection to check filtered output
echo "apple orange banana" | tr ' ' '\n' | grep "orange" > fruit.txt
cat fruit.txt
# Expected Output (in fruit.txt): orange

# Complex Test Case 16: Exported variable in a command chain
export FRUIT="apple"
echo "$FRUIT orange" | tr ' ' '\n' | grep "orange" > fruits.txt
cat fruits.txt
# Expected Output (in fruits.txt): orange

# Complex Test Case 17: Complex chaining with logical AND and OR operators
export EXISTING_VAR="Exists"
unset NON_EXISTING_VAR && echo "$EXISTING_VAR" || echo "Variable unset or missing"
# Expected Output: Exists

# Complex Test Case 18: Multi-step pipe with word filtering and uppercase transformation
echo "The quick brown fox jumps" | tr ' ' '\n' | grep "fox" | tr '[:lower:]' '[:upper:]' > output.txt
cat output.txt
# Expected Output (in output.txt): FOX

# Complex Test Case 19: Combining pipes with environment variable and output file verification
export WORD="shell"
echo "This is a shell test" | grep "$WORD" > shell_test.txt
cat shell_test.txt
# Expected Output (in shell_test.txt): This is a shell test

# Complex Test Case 20: Exit with status code verification
exit 5
# Expected Behavior: Shell exits with status code 5

# 1. Echo with pipe, redirection, and variable expansion
export TESTVAR="Hello"
echo "$TESTVAR, World!" | tr '[:lower:]' '[:upper:]' > output.txt
# Expected output in output.txt: HELLO, WORLD!

# 2. Export and use environment variable with multiple pipes
export GREETING="Hello"
echo "$GREETING, Shell!" | sed 's/Shell/World/' | tr '[:upper:]' '[:lower:]' | grep "hello"
# Expected output: hello, world!

# 3. Unset variable in a pipeline
export TEMP="Temporary"
echo "$TEMP should not appear" | { unset TEMP; echo "${TEMP:-Cleared}"; }
# Expected output: Cleared should appear instead of the original variable value

# 4. Create, read, and append using redirections
echo "Line 1" > test.txt
echo "Line 2" >> test.txt
cat < test.txt | grep "Line" | wc -l
# Expected output: 2

# 5. Export and access variables across multiple commands
export NAME="Minishell"
echo "$NAME is cool" > test_output.txt && cat test_output.txt | grep "cool"
# Expected output: Minishell is cool

# 6. Combine multiple pipes with a redirection
echo -e "apple\nbanana\ncarrot" | grep "a" | sort | tr 'a-z' 'A-Z' > sorted.txt
# Expected output in sorted.txt: APPLE\nBANANA\nCARROT (sorted and in uppercase)

# 7. Use cd, pwd, and output redirection to store directory path
cd /tmp && pwd > dir_path.txt && cd - > /dev/null
cat dir_path.txt
# Expected output: /tmp

# 8. Exit within a pipeline (should not terminate the shell entirely)
echo "Check exit within pipeline" | { echo "Message before exit"; exit 0; } | cat
# Expected output: Message before exit

# 9. Redirection with pipeline, modifying the output in sequence
echo "This is a test" | sed 's/test/experiment/' | tee output.txt | tr '[:lower:]' '[:upper:]'
# Expected output to terminal: THIS IS AN EXPERIMENT
# Expected content in output.txt: This is an experiment

# 10. Append output with multiple commands in background
(echo "First background line" >> output.txt; echo "Second background line" >> output.txt) &
wait
cat output.txt
# Expected output in output.txt: Both lines appended in order

# 11. Chained commands with conditional execution
export CONDITION=1
[ "$CONDITION" -eq 1 ] && echo "Condition met" || echo "Condition not met"
# Expected output: Condition met

# 12. Nested export and unset with pipes
export NESTED="Nested"
echo "$NESTED environment" | { unset NESTED; echo "${NESTED:-No variable}"; }
# Expected output: No variable

# 13. Command substitution with pipes and environment variable usage
export PREFIX="Super"
echo "$(echo "$PREFIX Shell") is awesome" | tr '[:upper:]' '[:lower:]'
# Expected output: super shell is awesome

# 14. Using exit with specific status codes
(exit 5); echo $?
# Expected output: 5 (exit status code from previous command should be displayed)

# 15. Test multiple pipes with intermediate redirection
echo -e "one\ntwo\nthree" | tee intermediate.txt | grep "two" | wc -c
# Expected output: 4 (length of "two\n")

# 16. Combination of pipes, cd, and environment variables
cd / && export PATH_VAR=$PATH && echo "$PATH_VAR" | grep "/bin"
# Expected output: should display part of the PATH that contains /bin

# 17. Pipe with both input and output redirection
echo "Hello Minishell" > input.txt
cat < input.txt | tr '[:lower:]' '[:upper:]' > upper_output.txt
cat upper_output.txt
# Expected output: HELLO MINISHELL

# 18. Testing nested quotes and pipes
echo 'This is "quoted" and $USER' | sed 's/USER/user/g' | tr '[:upper:]' '[:lower:]'
# Expected output: this is "quoted" and $user

# 19. Using multiple file descriptors with redirection
echo "Content for file descriptor test" > fd_test.txt
exec 3>fd_test_out.txt
cat < fd_test.txt >&3
exec 3>&-
cat fd_test_out.txt
# Expected output in fd_test_out.txt: Content for file descriptor test

# 20. Complex pipeline with conditional execution and redirection
echo "Test pipeline" | { grep "Test" && echo "Found test"; } > result.txt || echo "No test found"
cat result.txt
# Expected output in result.txt: Found test

# 21. Complex variable usage and unsetting
export COMPLEX_VAR="Complexity"
echo "$COMPLEX_VAR is important" | { unset COMPLEX_VAR; echo "${COMPLEX_VAR:-Unset variable}"; }
# Expected output: Unset variable


//-----Tests for commands pipes and redirections -----//

# 1. Pipe chain with simple redirection to a file
echo "Hello World" | tr '[:upper:]' '[:lower:]' > output.txt
# Expected output in output.txt: hello world
# Explanation: Tests if the output of the pipe chain is correctly redirected to a file.

# 2. Complex pipe chain with multiple transformations
echo "Hello World" | tr ' ' '\n' | grep "World" | tr '[:lower:]' '[:upper:]'
# Expected output: WORLD
# Explanation: Breaks "Hello World" into separate lines, searches for "World", and outputs it in uppercase.

# 3. Using a file as input, transforming content, and redirecting output to a new file
echo -e "line1\nline2\nline3" > input.txt
cat < input.txt | grep "line2" | tr '[:lower:]' '[:upper:]' > output.txt
# Expected output in output.txt: LINE2
# Explanation: Tests input redirection, filtering with `grep`, and final redirection to output.

# 4. Multiple pipes with intermediate file redirection
echo "apple\nbanana\ncarrot" | tee fruits.txt | grep "a" > result.txt
# Expected output in result.txt: apple\nbanana\ncarrot
# Explanation: Uses `tee` to write to a file mid-pipeline, filters for lines with "a," and redirects final output.

# 6. Testing redirection and append with pipes
echo "First line" > output.txt
echo "Second line" | tee -a output.txt | grep "Second" | tr '[:lower:]' '[:upper:]' >> output.txt
# Expected output in output.txt:
# First line
# Second line
# SECOND LINE
# Explanation: Appends output through multiple stages and checks if `-a` appends correctly.

# 8. Pipe with both input and output redirection
echo "Shell test" > input.txt
cat < input.txt | tr '[:lower:]' '[:upper:]' > output.txt
# Expected output in output.txt: SHELL TEST
# Explanation: Tests combined use of input redirection, pipes, and output redirection.

# 9. Multi-command pipeline with redirection and intermediate filtering
echo -e "Apple\nBanana\nCherry\nMango" | grep -i "a" | sort | tr '[:lower:]' '[:upper:]' > sorted_output.txt
# Expected output in sorted_output.txt:
# APPLE
# BANANA
# MANGO
# Explanation: Multiple filters in sequence, sorting, and final output redirection.

# 11. Redirecting stderr and stdout in a pipe
ls non_existent_file 2> error.log | cat nonexistent_file | tr '[:lower:]' '[:upper:]' > output.log
# Expected output in error.log: ls: cannot access 'non_existent_file': No such file or directory
# Expected output in output.log: (should be empty due to non-existent input)
# Explanation: Checks redirection of error output to a file and tests behavior with an invalid pipe stage.

# 12. Multiple redirections with a command in a pipeline
echo "First" > test.txt
echo "Second" | tee test.txt | tr '[:lower:]' '[:upper:]' >> test.txt
# Expected output in test.txt:
# Second
# SECOND
# Explanation: Combines `tee` and append redirection to test mid-pipeline redirection and appending.
